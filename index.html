<!--
COMP 4107 Assignment 1
-->
<html>
<head><title>COMP 4107 Assignment 1</title>
<script type="text/javascript" src="json2.js"></script>
<script type="text/javascript" src="jquery.js"></script>

</head>
<body>

<input type="button" value="Solve OneMax" onclick="one_max_init();">&nbsp;&nbsp;
<input type="button" value="Solve SimpleMax" onclick="simple_max_init();">&nbsp;&nbsp;
<input type="button" value="Solve Travelling Salesman" onclick="tsp_init();">&nbsp;&nbsp;
<label>&nbsp;Map:
<select id="tsp_map">
<option>berlin52</option>
<option>square</option>
<option>circle</option>
<option>random</option>
</select>
</label>
<label>&nbsp;Selection:
<select id="selection">
<option>rank</option>
<option>tournament</option>
</select>
</label>
<input type="button" style="color:red;" value="Stop" onclick="stop();">&nbsp;&nbsp;

<br>
<div id="result"></div>
<canvas id="canvas" width="900" height="600" style="display:none;"></canvas>
<br>
<h2>Purpose</h2>
<p>The goal of this application is to use a genetic algorithm to find solutions to several problems, primarily the <a href='http://en.wikipedia.org/wiki/Travelling_salesman_problem'>travelling salesman problem</a>.</p>
<h2>Genetic Algorithm</h2>
<p>Genetic Algorithms work by creating a population of randomly generated possible solutions to a problem. Each individual competes against others to see who will reproduce based on a fitness which is determined by how close an individual is to the best solution. Two individuals are selected, and their genetic material (pieces of the possible answer) are combined randomly. As each generation passes, the solutions evolve closer to the ideal answer. The "correct" answer may never be found, but a "close enough" answer usually is.</p>
<p>The solutions to the problems found on this page are of fixed size. For example, the solution to Simple Max has exactly 10 genes. Some problems allow the number of genes to increase without bounds. </p>
<p>Once the optimal solution is found, the algorithm continues to search, because it doesn't know if it has found the best answer yet. In order to avoid searching forever, we limit the number of generations before stopping the search.</p>
<h3>One Max</h3>
<p>One Max seeks to maximize the number of 1's. A gene can be either a 1 or a 0. The best solution is one where all genes are a 1 as this would give the highest number of 1's.</p>
<h3>Simple Max</h3>
<p>Simple Max seeks to maximize the value of (x<sub>1</sub>*x<sub>2</sub>*x<sub>3</sub>*x<sub>4</sub>*x<sub>5</sub>)/(x<sub>6</sub>*x<sub>7</sub>*x<sub>8</sub>*x<sub>9</sub>*x<sub>10</sub>). Each x<sub>n</sub> is a gene which can have a value of 1 to 10. The best solution is (10*10*10*10*10)/(1*1*1*1*1). </p>
<h3>Travelling Salesman Problem</h3>
<p>The Travelling Salesman Problem seeks to find the shortest (or least expensive) path that will allow a salesman to visit each city and return home. The optimal answer for the Square, Circle and Random maps is found quickly. The Berlin52 map takes significantly longer, since there are so many possibilities.</p>


<script type="text/javascript">
var ctx = document.getElementById('canvas').getContext("2d");

//config object used to set the parameters of the game. This object is passed to the worker thread to initialize it
var config = new Object();
config.popSize = 50;
config.maxGenerations = 35;
config.maxRuns = 1;
config.mutateProb = 0.02;
config.selection = "rank";
config.fitness_order = "asc";
config.unique_chromosomes = false;
var worker;
worker = new Worker("ga.js");
worker.onerror = function(error) {  
	console.log(error.message);
};

//start the run loop
function one_max_init(){
	stop();
	config.fitness_alg = "one_max";
	config.fitness_order = "asc";
	config.chromosome_length = 50;
	config.maxGenerations = 35;
	config.chars = ['0','1'];
	config.unique_chromosomes = false;
	config.selection = $('#selection').val();
	$('#result').empty();
	$('#canvas').hide();
	
	worker.onmessage = function(event) {
		handle_worker_message_onemax(event.data);
	};
	var message = new Object();
	message.act = "init";
	message.data = config;
	worker.postMessage(JSON.stringify(message));
}

function simple_max_init(){
	stop();
	config.fitness_alg = "simple_max";
	config.fitness_order = "asc";
	config.chromosome_length = 10;
	config.maxGenerations = 35;
	config.chars = [1,2,3,4,5,6,7,8,9,10];
	config.unique_chromosomes = false;
	config.selection = $('#selection').val();
	$('#result').empty();
	$('#canvas').hide();
	
	worker.onmessage = function(event) {
		handle_worker_message_simplemax(event.data);
	};
	var message = new Object();
	message.act = "init";
	message.data = config;
	worker.postMessage(JSON.stringify(message));
}

function tsp_init(){
	stop();
	$.get($('#tsp_map').val()+'.txt', function(data){
  		config.fitness_alg = "tsp";
  		config.fitness_order = "desc";
		config.unique_chromosomes = true;
  		config.chars = new Array();
  		config.cities = new Object();
  		config.popSize = 250;
  		config.maxGenerations = 1000;
  		config.selection = $('#selection').val();
  		var lines=data.split("\n");
  		for(var i=0; i<lines.length; i++) {
  			var parts = lines[i].split(' ');
  			if(parts.length != 3)
  				continue;
  			config.chars.push(parts[0]);
  			var city = new Object();
  			city.x = parts[1];
  			city.y = parts[2];
  			config.cities[parts[0]] = city;
  		}
		//number of cities
		config.chromosome_length = config.chars.length;
		
		$('#result').empty();
		$('#canvas').show();
		draw_cities();
		
		worker.onmessage = function(event) {
			handle_worker_message_tsp(event.data);
		};
		var message = new Object();
		message.act = "init";
		message.data = config;
		worker.postMessage(JSON.stringify(message));
	});
}


function handle_worker_message_onemax(data){
	var resultObj = JSON.parse(data);
	if(resultObj.act == "debug"){
		console.log(resultObj.data);
		return false;
	}
	if(resultObj.act == "generation" && resultObj.gen){
		$('#result').prepend("Best individual of generation "+resultObj.gen+": "+resultObj.data.chromosome+" ("+resultObj.data.fitness+")<br>");
		return true;
	}
	if(resultObj.act == "answer"){
		$('#result').prepend("Answer: "+resultObj.data.chromosome+"<br>With a fitness of "+resultObj.data.fitness+"<br>");
		return true;
	}
}
function handle_worker_message_simplemax(data){
	var resultObj = JSON.parse(data);
	if(resultObj.act == "debug"){
		console.log(resultObj.data);
		return false;
	}
	if(resultObj.act == "generation" && resultObj.gen){
		$('#result').prepend("Best individual of generation "+resultObj.gen+": (" + resultObj.data.chromosome[0] + "*"+ resultObj.data.chromosome[1] + "*"+ resultObj.data.chromosome[2] + "*"+ resultObj.data.chromosome[3] + "*"+ resultObj.data.chromosome[4] + ")/("+ resultObj.data.chromosome[5] + "*"+ resultObj.data.chromosome[6] + "*"+ resultObj.data.chromosome[7] + "*"+ resultObj.data.chromosome[8] + "*"+ resultObj.data.chromosome[9] +") = "+resultObj.data.fitness+"<br>");
		return true;
	}
	if(resultObj.act == "answer"){
		$('#result').prepend("Answer: (" + resultObj.data.chromosome[0] + "*"+ resultObj.data.chromosome[1] + "*"+ resultObj.data.chromosome[2] + "*"+ resultObj.data.chromosome[3] + "*"+ resultObj.data.chromosome[4] + ")/("+ resultObj.data.chromosome[5] + "*"+ resultObj.data.chromosome[6] + "*"+ resultObj.data.chromosome[7] + "*"+ resultObj.data.chromosome[8] + "*"+ resultObj.data.chromosome[9] +") = "+resultObj.data.fitness+"<br>");
		return true;
	}
}


function handle_worker_message_tsp(data){
	var resultObj = JSON.parse(data);
	if(resultObj.act == "debug"){
		console.log(resultObj.data);
		return false;
	}
	if(resultObj.act == "generation"){
		$('#result').html("Fitness: "+resultObj.data.fitness+"<br>");
		draw_tsp(resultObj.data.chromosome);
		return true;
	}
	if(resultObj.act == "answer"){
		$('#result').html("Done: Fitness: "+resultObj.data.fitness+"<br>");
		draw_tsp(resultObj.data.chromosome);
		return true;
	}
}

function draw_cities(){
	ctx.clearRect(0, 0, 900, 600);
	ctx.fillStyle = "#000";
	for(i in config.cities){
		ctx.beginPath();
		ctx.arc(config.cities[i].x/2,config.cities[i].y/2,2,0,Math.PI*2,true);
		ctx.fill();
	}
}

function draw_tsp(path){
	draw_cities();
	ctx.fillStyle = "#0F0";
	ctx.beginPath();
	ctx.arc(config.cities[path[0]].x/2,config.cities[path[0]].y/2,2,0,Math.PI*2,true);
	ctx.fill();
	ctx.strokeStyle = "#666";
	ctx.beginPath();
	ctx.moveTo(config.cities[path[0]].x/2,config.cities[path[0]].y/2);
	for(var i=0;i<path.length;i++){
		ctx.lineTo(config.cities[path[i]].x/2,config.cities[path[i]].y/2);
	}
	ctx.lineTo(config.cities[path[0]].x/2,config.cities[path[0]].y/2);
	ctx.stroke();  
}

//pause the game
function stop(){
	var message = new Object();
	message.act = "pause";
	worker.postMessage(JSON.stringify(message));
}

function test_crossover(){
	stop();
	$('#result').empty();
	
	worker.onmessage = function(event) {
		var resultObj = JSON.parse(event.data);
		$('#result').append("Order Crossover: "+resultObj.data.a1);
		$('#result').append("<br>Position-based crossover: "+resultObj.data.a2);
	};
	var message = new Object();
	message.act = "test_crossover";
	message.data = new Object();
	var string = prompt("Enter values for parent 1 separated by a comma (,).\nFor Example: 1,2,3,4");
	if(!string)
		return false;
	message.data.parent1 = string.split(',');
	string = prompt("Enter values for parent 2 separated by a comma (,).\nFor Example: 1,2,3,4");
	if(!string)
		return false;
	message.data.parent2 = string.split(',');;
	worker.postMessage(JSON.stringify(message));
}



</script>

</body>
</html>